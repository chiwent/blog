(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{86:function(t,a,s){"use strict";s.r(a);var n=s(0),e=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"vue基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue基础","aria-hidden":"true"}},[t._v("#")]),t._v(" Vue基础")]),s("h2",{attrs:{id:"vue的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue的生命周期","aria-hidden":"true"}},[t._v("#")]),t._v(" Vue的生命周期")]),s("p",[t._v("vue的生命周期是什么，简单地说句就是一个组件自创建到销毁经历的各种状态。vue提供了一些生命周期相关的钩子函数（命名固定），可以方便开发者在组件的不同时期定义不同的行为方法，vue在执行的时候会自动调用生命周期钩子函数。"),s("br")]),s("p",[t._v("vue文档上有一张图大致总结了vue的生命周期： https://cn.vuejs.org/v2/guide/instance.html"),s("br")]),s("p",[t._v("另外还有一张介绍各个钩子函数的使用场景：\n"),s("img",{attrs:{src:"https://raw.githubusercontent.com/chiwend/img/master/PciGovue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0.webp",alt:"vue钩子函数使用场景"}})]),s("p",[t._v("下面介绍vue组件一个生命周期内会涉及到的钩子函数："),s("br")]),s("h3",{attrs:{id:"_1-beforecreate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-beforecreate","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.beforeCreate")]),s("p",[t._v("vue实例还没有创建，这个时期实例的data、methods都是读取不到的")]),s("h3",{attrs:{id:"_2-create"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-create","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.create")]),s("p",[t._v("vue实例已经创建，这个时期可以使用data和methods，也完成了watch/event事件回调，但是挂载还没有开始，$el属性不可见，data数据也没有在DOM上渲染出来"),s("br")]),s("h3",{attrs:{id:"_3-beforemounted"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-beforemounted","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.beforeMounted")]),s("p",[t._v("在挂载前调用，开始调用render函数"),s("br")]),s("h3",{attrs:{id:"_4-mounted"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-mounted","aria-hidden":"true"}},[t._v("#")]),t._v(" 4.mounted")]),s("p",[t._v("vue实例已经挂载到页面中，el选项的DOM节点被新创建的vm.$el替换，可以获取到el中的DOM元素，并且操作DOM。"),s("br"),t._v("\n使用场景：如果需要在实例挂载后马上进行相关的DOM操作，可以将方法写在mounted钩子内"),s("br")]),s("h3",{attrs:{id:"_5-beforeupdate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-beforeupdate","aria-hidden":"true"}},[t._v("#")]),t._v(" 5.beforeUpdate")]),s("p",[t._v("数据更新时使用，但是不会对DOM重新渲染。"),s("br"),t._v("\n使用场景：在数据更新时DOM没渲染前，可以在这个钩子内进行状态处理，这样不会触发附加的重新渲染"),s("br")]),s("h3",{attrs:{id:"_6-updated"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-updated","aria-hidden":"true"}},[t._v("#")]),t._v(" 6.updated")]),s("p",[t._v("数据已更新且组件DOM已经重新渲染，这时可以执行依赖于DOM的操作。当实例每次数据更新时，该钩子都会被调用"),s("br")]),s("h3",{attrs:{id:"_7-beforedestory"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-beforedestory","aria-hidden":"true"}},[t._v("#")]),t._v(" 7.beforeDestory")]),s("p",[t._v("实例销毁前的调用")]),s("h3",{attrs:{id:"_8-destoryed"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-destoryed","aria-hidden":"true"}},[t._v("#")]),t._v(" 8.destoryed")]),s("p",[t._v("实例销毁后的调用，vue实例相关的内容都会解绑，所有事件监听器都会移除，所有子实例也会移除"),s("br")]),s("h2",{attrs:{id:"全局api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全局api","aria-hidden":"true"}},[t._v("#")]),t._v(" 全局API")]),s("h3",{attrs:{id:"extend"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#extend","aria-hidden":"true"}},[t._v("#")]),t._v(" extend")]),s("p",[t._v("使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。"),s("br"),t._v("\n和Vue.component的区别："),s("br"),t._v("\nVue.extend返回的是一个扩展实例构造器（不是组件哦），预设了部分的Vue选项，需要传入component来进行注册。"),s("br"),t._v("\nVue.component是用来去全局注册组件的，通过Vue.extend生成的扩展实例构造器来注册一个组件，它可以取得组件，也可以创建组件。"),s("br")]),s("p",[t._v("demo和更多介绍可以参考官方文档：https://cn.vuejs.org/v2/api/#Vue-extend"),s("br")]),s("h2",{attrs:{id:"数据相关"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据相关","aria-hidden":"true"}},[t._v("#")]),t._v(" 数据相关")]),s("p",[t._v("注意："),s("br"),t._v("\n在混入Vue实例的属性中如果使用了箭头函数，里面的this不会指向该组件的实例，不过，你可以将实例作为函数的第一个参数传递进去访问，如："),s("br")]),s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" vm "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{attrs:{class:"token class-name"}},[t._v("Vue")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tdata"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" vm "),s("span",{attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" a"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" vm"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("test "),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),s("h3",{attrs:{id:"data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data","aria-hidden":"true"}},[t._v("#")]),t._v(" data")]),s("p",[t._v("一般来说，它可以写成对象或者函数的形式，但是在组件复用的时候，它必须是一个函数: "),s("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0",target:"_blank",rel:"noopener noreferrer"}},[t._v("组件的复用")]),s("br"),t._v("\n如果写成对象形式，那么组件在复用的时候，多个实例同时引用一个对象，当修改其中一个实例的属性时，其他的实例也会被修改。所以在组件复用的时候，我们要将data写成函数形式"),s("br")]),s("p",[t._v("有关data相关的内容参考"),s("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#data",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档")]),s("br")]),s("h3",{attrs:{id:"props"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#props","aria-hidden":"true"}},[t._v("#")]),t._v(" props")]),s("p",[t._v("用于父子组件间的通信。props可以是数组或对象，如果使用对象，允许配置数据类型、自定义校验和设置默认值"),s("br")]),s("h3",{attrs:{id:"computed"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#computed","aria-hidden":"true"}},[t._v("#")]),t._v(" computed")]),s("p",[t._v("计算属性混入vue实例中，所有的getter和setter内的this都指向vue"),s("br"),t._v("\n其结果会被缓存，，除非依赖的响应式属性发生变化才会重新计算。\n参考: "),s("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-vs-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档-计算属性")]),s("br")]),s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[t._v("var vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    double: function () {\n      return this.a * 2\n    },\n    plus: {\n      get() {\n        return this.a + 1\n      },\n      set(v) {\n        this.a = v\n      }\n    }\n  }\n})\nconsole.log(vm.plus)  // -> 2\nvm.plus = 4\nconsole.log(vm.a)       // -> 4\nconsole.log(vm.double) // -> 8\n")])]),s("p",[t._v("computed适用场景："),s("br"),t._v("\n如果模板上涉及到一些比较复杂的逻辑或运算，那么可以在computed中处理："),s("br")]),s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),s("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("{{ message.split('').reverse().join('') }}"),s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),s("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\n"),s("span",{attrs:{class:"token comment"}},[t._v("\x3c!-- 改为 --\x3e")]),t._v("\n"),s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),s("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("{{ reverseMessage }}"),s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),s("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\n"),s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("script")]),s("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{attrs:{class:"token script language-javascript"}},[t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{attrs:{class:"token function"}},[t._v("data")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),s("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t\tmessage"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{attrs:{class:"token string"}},[t._v("'Hi'")]),t._v("\n\t\t\t"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\tcomputed"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),s("span",{attrs:{class:"token function"}},[t._v("reverseMessage")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t\t"),s("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("message"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("split")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token string"}},[t._v("''")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("reverse")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("join")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token string"}},[t._v("''")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t\t\t"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")]),s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("</")]),t._v("script")]),s("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),s("p",[t._v("注意，不要在computed内修改所依赖的数据，只能对依赖的数据做运算后返回其运算结果，否则computed将被一直触发"),s("br")]),s("h3",{attrs:{id:"methods"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#methods","aria-hidden":"true"}},[t._v("#")]),t._v(" methods")]),s("p",[t._v("混入vue实例中，方法内的this自动绑定为vue实例。"),s("br"),t._v("\n一般来说，混入vue实例的属性中不建议使用箭头函数，原因前面已经提到了，所以在methods内定义的函数也不要用箭头函数"),s("br")]),s("p",[t._v("computed和methods的区别："),s("br"),t._v("\n一般的，将需要计算的属性放到computed和method中都是可以修改数据的。只不过，computed是响应式的，methods是非响应式的。computed计算属性是可以缓存的，只要依赖的数据(一般是监听data属性的内容)不发生变化，就不会调用。如果需要进行较大的操作，那么可以将这个计算放入computed中。如果是放在methods中，每次重绘时都会触发这个计算（尽管本意不是一直需要），这样就比较耗费性能了。另外，computed的成员可以只定义一个函数作为只读属性，也可以定义get/set编程读写属性，methods无法做到"),s("br"),t._v("\n再简单地说，computed是计算属性，可以实时响应，比如要监听data内的值的变化而做出一些动作，就用computed；methods是方法，比如要在某个事件触发时执行一个方法，就用methods"),s("br")]),s("h3",{attrs:{id:"watch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#watch","aria-hidden":"true"}},[t._v("#")]),t._v(" watch")]),s("p",[t._v("它是一个对象，键名是需要观察的表达式，值是对应的回调函数或包含选项的对象。vue实例会在实例化时调用$watch()遍历watch对象的每个属性 "),s("br")]),s("p",[t._v("所以在使用watch的过程是这样的：实例化vue、调用$watch方法、属性变化后触发回调"),s("br")]),s("p",[t._v("它和computed有什么区别？"),s("br"),t._v("\n二者都是有监听数据的能力，不同的是，如果需要监听多个数据并进行处理时，computed可以在一个表达式中同时引用多个监听的数据，而watch需要被每个监听的数据分配一个方法，vue官方有个demo可以说明这个问题："),s("br")]),s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),s("span",{attrs:{class:"token attr-name"}},[t._v("id")]),s("span",{attrs:{class:"token attr-value"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{attrs:{class:"token punctuation"}},[t._v('"')]),t._v("demo"),s("span",{attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("{{ fullName }}"),s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\n"),s("span",{attrs:{class:"token comment"}},[t._v("\x3c!-- computed --\x3e")]),t._v("\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar'\n  },\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n})\n\n"),s("span",{attrs:{class:"token comment"}},[t._v("\x3c!-- watch --\x3e")]),t._v("\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  },\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n")])]),s("p",[t._v("上面的例子中，我们本意中需要监听的数据是firstName和lastName，并在")]),s("h3",{attrs:{id:"nexttick"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nexttick","aria-hidden":"true"}},[t._v("#")]),t._v(" nextTick")]),s("p",[t._v("官方文档的说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM"),s("br")]),s("p",[t._v("举个例子："),s("br")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("<div class=\"app\">\n\t<div ref=\"demo\">{{demo}}</div>\n\t<button @click=\"handler\">Click me</button>\n</div>\n\nnew Vue({\n\tel: '.app',\n\tdata() {\n\t\t\treturn {\n\t\t\t\tdemo: 'before click'\n\t\t\t};\n\t\t},\n\tmethods: {\n\t\thandler() {\n\t\t\tthis.demo = 'after click';\n\t\t\tconsole.log('1.' + this.$refs.demo.innerText);  // 1.before click\n\t\t\tthis.$nextTick(() => {\n\t\t\t\tconsole.log('2.' + this.$refs.demo.innerText); // 2.after click\n\t\t\t})\n\t\t}\n\t}\n})\n")])]),s("p",[t._v("在上面的例子中，nextTick中才正确地实现了我们的目的，这是因为vue中的DOM更新是异步的。如果需要更新的内容渲染到DOM节点后，我们要根据DOM元素拿到更新后的数据，那么我们就需要在nextTick的回调内获取"),s("br")]),s("p",[t._v("在created钩子函数进行的DOM操作一定要放在nextTick的回调中。因为created执行时DOM并没有渲染，执行DOM操作是没有意义的，所以一定要将DOM操作的相关代码放在nextTick的回调中。如果是在mounted钩子中，因为此时的DOM挂载和渲染已经完成，所以在这里不用nextTick也可以。但是假如数据变化后要执行的某个操作，这个操作需要使用随数据变化而变化的DOM结构时，就应该放在nextTick回调中。"),s("br")]),s("p",[t._v("官方的说明："),s("br")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0)代替。\n")])]),s("hr"),s("br"),t._v("\n### 参考\nvue官方文档"),s("br"),t._v("\n[掘金-简单理解Vue中的nextTick](https://juejin.im/post/5a6fdb846fb9a01cc0268618)"),s("br")])}],!1,null,null,null);a.default=e.exports}}]);