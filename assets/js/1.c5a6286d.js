(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{70:function(t,e,r){"use strict";r.r(e);var n=r(0),a=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"简单的图像处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简单的图像处理","aria-hidden":"true"}},[t._v("#")]),t._v(" 简单的图像处理")]),r("p",[t._v("在这篇文章，将简要地分别通过MATLAB、Python、JavaScript来实现一些图像处理的基本操作"),r("br")]),r("h2",{attrs:{id:"python篇"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#python篇","aria-hidden":"true"}},[t._v("#")]),t._v(" Python篇")]),r("h3",{attrs:{id:"获取图片的信息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#获取图片的信息","aria-hidden":"true"}},[t._v("#")]),t._v(" 获取图片的信息")]),r("h4",{attrs:{id:"图像的尺寸"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图像的尺寸","aria-hidden":"true"}},[t._v("#")]),t._v(" 图像的尺寸")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import cv2\nimg = cv2.imread('test.jpg')\nsize = img.shape\nprint(size)\nheight,width,channels = img.shape\nprint(height,width,channels)\n\n# 或者\n\nfrom PIL import Image\nimg = Image.open('test.jpg')\nimgSize = img.size\nprint(max(imgSize),min(imgSize))\n")])]),r("h4",{attrs:{id:"图片缩放"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图片缩放","aria-hidden":"true"}},[t._v("#")]),t._v(" 图片缩放")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("samll_img = cv2.resize(src=img, dsize=None, fx=0.5, fy=0.5)\n# 宽高缩小为原来的一半\n")])]),r("h4",{attrs:{id:"复制图像"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复制图像","aria-hidden":"true"}},[t._v("#")]),t._v(" 复制图像")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import cv2\nimport numpy as np\n\nimg = cv2.imread('test.jpg')\nsize = img.shape\nim = np.zeros(img.shape, np.uint8)\n\n# 也可以直接：\nim = img.copy()\n")])]),r("h4",{attrs:{id:"pil图片和opencv图片相互转换"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pil图片和opencv图片相互转换","aria-hidden":"true"}},[t._v("#")]),t._v(" PIL图片和opencv图片相互转换")]),r("p",[t._v("OpenCV to PIL:"),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("pil = Image.fromarray(cv2.cvtColor(cv, cv2.COLORBGR2RGB))\n")])]),r("p",[t._v("PIL to OpenCV:"),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("pil = PIL.Image.open('test.jpg').convert('RGB')\ncv = numpy.array(pil)\ncv = cv[:,:,::-1].copy()\n")])]),r("h3",{attrs:{id:"灰度化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#灰度化","aria-hidden":"true"}},[t._v("#")]),t._v(" 灰度化")]),r("h4",{attrs:{id:"通过matplotlab库灰度化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#通过matplotlab库灰度化","aria-hidden":"true"}},[t._v("#")]),t._v(" 通过matplotlab库灰度化")]),r("p",[t._v("首先安装"),r("code",[t._v("matplotlab")]),t._v("库："),r("code",[t._v("sudo pip install matplotlib")]),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import matplotlib.pyplot as plt\nimport matlotlib.image as mpimg\nimport numpy as np\nimg = mpimg.imread('test.jpg')\nimg.shape \n# (282, 292, 3)\nplt.axis('on') #显示坐标轴\nplt.show()  #显示原图片\n\ndef rgb2gray(rgb):\n    return np.dot(rgb[...,:3], [0.299, 0.587, 0.114])\n\ngray = rgb2gray(img)\nplt.imshow(gray,cmap = plt.get_cmap('gray'))\nplt.axis('on')\nplt.show()\n")])]),r("h4",{attrs:{id:"通过pil灰度化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#通过pil灰度化","aria-hidden":"true"}},[t._v("#")]),t._v(" 通过PIL灰度化")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("from PIL import Image\nimg = Image.open('test.jpg')\nimg.show() # 显示原图\nL = img.convert('L') # 灰度化\nL.show() # 显示灰度图\nL = img.convert('1') # 二值化\nL.show() # 二值化图\n")])]),r("p",[t._v("扩展：将某路径下的所有彩色图片灰度化："),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("from PIL import Image\nimport os\ndef get_path(path):\n\treturn [os.path.join(path,f) for f in os.listdir(path) if f.endswith('.jpg')]\npth = get_path('./')\nprint(pth)\nfor img in pth:\n\toutfile = os.path.splitext(img)[0] + '.jpg'\n\tprint(outfile)\n\tif './gray'+outfile.split('./')[1] not in pth and 'gray' not in outfile:\n\t#if 'gray' not in outfile:\n\t\t#print('1'+img)\n\t\ttry:\n\t\t\timg = Image.open(img).convert('L')\n\t\t\t#print('img',img)\n\t\t\t#img.show()\n\t\t\tim = 'gray' + outfile.split('./')[1]\t\n\t\t\timg.save(im)\n\t\texcept IOError:\n\t\t\tprint('can not convert',img)\n\n")])]),r("h4",{attrs:{id:"通过opencv灰度化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#通过opencv灰度化","aria-hidden":"true"}},[t._v("#")]),t._v(" 通过opencv灰度化")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import cv2\nfrom matpplotlib import pyplot as plt\nim = cv2.imread('test.jpg')\ngray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)\nplt.axis('off')\nplt.imshow(im,'gray') # = plt.imshow(gray,cmap='gray') or plt.imshow(gray, cmap=plt.get_cmap('gray'))\nplt.show()\n")])]),r("p",[t._v("在一些编程社区上经常看到："),r("code",[t._v("cv2.imshow(gray,'gray')")]),t._v("这样的代码，但是查阅了Python opencv官网却没发现这样的格式。并且本人在调用opencv的时候调用了"),r("code",[t._v("cv2.imshow('img',img)")]),t._v("，然后就出现了进程无反应的状况，目前原因不详"),r("br")]),r("p",[t._v("问题解决：针对上述不显示图片并且进程卡死的问题，给出下列的解决方案："),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import cv2\nim = cv2.imread('test1.jpg') # cv2.imread('test1.jpg',0)直接输出灰度图\ngray = cv2.cvtColor(im,cv2.COLOR_RGB2GRAY) \ncv2.nameWindow('gray',0)\ncv2.startWindowThread()\ncv2.imshow('gray',gray)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n")])]),r("p",[t._v("bug解决请参考："),r("a",{attrs:{href:"https://blog.csdn.net/GAN_player/article/details/75098226",target:"_blank",rel:"noopener noreferrer"}},[t._v("cv2.destoryAllWindows()无效的解决方法")]),r("br")]),r("p",[t._v("详情可以查看opencv官方文档：https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_gui/py_image_display/py_image_display.html"),r("br")]),r("h3",{attrs:{id:"二值化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二值化","aria-hidden":"true"}},[t._v("#")]),t._v(" 二值化")]),r("h4",{attrs:{id:"opencv"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#opencv","aria-hidden":"true"}},[t._v("#")]),t._v(" opencv")]),r("p",[t._v("固定阈值二值化"),r("br"),t._v("\n用到的函数："),r("code",[t._v("cv2.threshold(src, thresh, maxval, type[, dst])")]),t._v("，返回值为"),r("code",[t._v("retval、dst")]),r("br")]),r("p",[t._v("参数说明：")]),r("ul",[r("li",[t._v("src:输入图像")]),r("li",[t._v("thresh：阈值")]),r("li",[t._v("maxval：输出图像最大值")]),r("li",[t._v("type：阈值类型")]),r("li",[t._v("dst：目标图像")])]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("retval, im = cv2.threshold(gray, 50, 255, cv2.THRESH_BINARY)\nplt.axis('off')\nplt.title('二值化')\nplt.imshow()\n")])]),r("br"),t._v("\n算法平均法的自适应二值化和高斯加权均值自适应二值化"),r("br"),t._v("\n用到的函数：`cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst])`，返回值为`dst`"),r("br"),r("p",[t._v("参数说明：")]),r("ul",[r("li",[t._v("src：输入图像")]),r("li",[t._v("maxval：输出图像的最大值")]),r("li",[t._v("adaptiveMethod：设置为"),r("code",[t._v("cv2.ADAPTIVE_THRESH_MEAN_C")]),t._v("表示使用算术平均值法，设置为"),r("code",[t._v("cv2.ADAPTIVE_THRESH_GAUSSIAN_C")]),t._v("表示使用高斯权重均值法")]),r("li",[t._v("thresholdType：阈值类型")]),r("li",[t._v("blockSize：b的值")]),r("li",[t._v("C：从均值中减去的常数，用于得到阈值")]),r("li",[t._v("dst：目标图像")])]),r("p",[t._v("这里，我们将b设为5，C设为10"),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("im = cv2.adaptiveThreshold(gray,255,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,5,10)\nplt.axis('off')\nplt.title('Adaptive Thresholding')\nplt.imshow(im, cmap='gray')\nplt.show()\n")])]),r("h3",{attrs:{id:"绘制直方图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#绘制直方图","aria-hidden":"true"}},[t._v("#")]),t._v(" 绘制直方图")]),r("h4",{attrs:{id:"通过matplotlib库绘制灰度直方图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#通过matplotlib库绘制灰度直方图","aria-hidden":"true"}},[t._v("#")]),t._v(" 通过matplotlib库绘制灰度直方图")]),r("p",[t._v("灰度图可以使用"),r("code",[t._v("hist")]),t._v("函数绘制，这个函数第一个参数只能接受一位数组作为输入，所以第一个参数需要通过"),r("code",[t._v("flatten")]),t._v("将任意数组按照行优先准则转换为一维数组；第二个参数则是规定小区间的数目。"),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("from PIL import Image\nfrom pylab import *\n# 图片转换为数组并灰度化\nimg = array(Image.open('test.jpg').convert('L'))\n# 直方图图像\nhist(img.flatten(),128)\nshow()\n")])]),r("p",[t._v("或者这样："),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nim = np.array(Image.open('test.jpg').convert('L'))\nplt.figure('gray')\nplt.title('gray')\narr = im.flatten()\nn,bins,patches = plt.hist(arr, bins=256, density=1, facecolor='blue', alpha=0.7)\nplt.show()\n")])]),r("p",[r("code",[t._v("hist")]),t._v("的参数说明：")]),r("ul",[r("li",[t._v("arr: 需要计算直方图的一维数组")]),r("li",[t._v("bins：直方图柱数，可选，默认为10")]),r("li",[t._v("density/normed：是否将得到的直方图向量归一化，默认为0")]),r("li",[t._v("facecolor：直方图颜色")]),r("li",[t._v("alpha：透明度")])]),r("p",[t._v("facecolor和edgecolor可以分别简写为"),r("code",[t._v("fc")]),t._v("和"),r("code",[t._v("ec")]),r("br")]),r("p",[t._v("更多函数说明参考官方库：https://matplotlib.org/api/_as_gen/matplotlib.pyplot.hist.html"),r("br")]),r("p",[t._v("如果需要显示彩色图的直方图："),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("from PIL import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\nim = Image.open('test.jpg')\nr,g,b = im.split()\n# 也可以r = im[:,:,0], g = im[::,1], b = im[:,:,2]\nplt.figure('Origin')\nplt.title('Origin')\narr = np.array(r).flatten()\nplt.hist(arr, bins=256, density=1, facecolor='r', edgecolor='r', hold=1)\narr = np.array(g).flatten()\nplt.hist(arr, bins=256, density=1, facecolor='g', edgecolor='g', hold=1)\narr = np.array(b).flatten()\nplt.hist(arr, bins=256, density=1, facecolor='b', edgecolor='b', hold=1)\nplt.show()\n")])]),r("br"),r("h3",{attrs:{id:"形态学"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#形态学","aria-hidden":"true"}},[t._v("#")]),t._v(" 形态学")]),r("h4",{attrs:{id:"膨胀和腐蚀"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#膨胀和腐蚀","aria-hidden":"true"}},[t._v("#")]),t._v(" 膨胀和腐蚀")]),r("p",[t._v("和MATLAB一样，Python opencv的膨胀腐蚀函数分别是"),r("code",[t._v("dilate")]),t._v("和"),r("code",[t._v("erode")]),r("br")]),r("p",[t._v("简单地先通过OTSU二值化再进行腐蚀膨胀："),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("#coding=utf-8\n\nimport cv2\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\nwhile(1):\n\tim = cv2.imread('zui.jpg',0)\n\tret,th = cv2.threshold(im, 0, 255, cv2.THRESH_OTSU)\n\t#plt.imshow(th,'otsu')\n\tkernel = np.ones((3,3),np.uint8)\n\tim1 = cv2.erode(th,kernel,iterations=7)\n\tim2 = cv2.dilate(im1,kernel,iterations=1)\n\tcv2.imshow('dilation',im2)\n\tif cv2.waitKey(0):\n\t\tbreak\ncv2.destroyAllWindows()\n")])]),r("p",[t._v("开运算和闭运算："),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import cv2\nimport numpy as np\nwhile(1):\n    im = cv2.imread('test.jpg',0)\n    kernel = np.ones((3,3),np.uint8)\n    # or cv2.getStructuringElement(cv2.MORPH_RECT,(3,3))\n    open = cv2.morphologyEx(im, cv2.MORPH_OPEN, kernel)\n    # 如果是闭运算就是cv2.MORPH_CLOSE\n    cv2.imshow('Gray',im)\n    cv2.imshow('opening',open)\n    if cv2.waitKey(0):\n        break\ncv2.destroyAllWindows()\n")])]),r("p",[t._v("更多有关Python opencv形态学的内容可以看："),r("a",{attrs:{href:"http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_morphological_ops/py_morphological_ops.html?highlight=getstructuringelement",target:"_blank",rel:"noopener noreferrer"}},[t._v("OpenCV-Python Tuorials Morphological Transformations")]),r("br")]),r("p",[t._v("边沿检测："),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("#coding=utf-8\n\nimport cv2\nimport numpy as np\n\nim = cv2.imread('zui.jpg')\nim = cv2.cvtColor(im, cv2.COLOR_RGB2GRAY)\nkernel = cv2.getStructuringElement(cv2.MORPH_RECT,(3,3))\ndilation = cv2.dilate(im,kernel)\nerodetion = cv2.erode(im, kernel)\nedge = cv2.absdiff(dilation, erodetion) #两幅图相减得到边缘\nret,edge = cv2.threshold(edge, 50, 100, cv2.THRESH_BINARY) #二值化后观察更清晰\nedge = cv2.bitwise_not(edge) #颜色反转\ncv2.imshow('Origin',im)\ncv2.imshow('Edge',edge)\nif cv2.waitKey(0):\n\tcv2.destroyAllWindows()\n")])]),r("p",[t._v("角点检测:"),r("br")]),r("p",[t._v("基本原理："),r("br"),t._v("\n建立一个窗口区域，该窗口向各个方向进行平移，如果在没有遇到边角的情况下，窗口像素不会发送变化；如果窗口在偏移过程压过一条直线，并且沿着这条直线的方向进行平移，窗口像素值也不会变化；假如遇到了拐角，窗口偏移后任意方向都会有像素改变，即判断为角点"),r("br")]),r("p",[t._v("基本方法："),r("code",[t._v("cv2.cornerHarris()")]),t._v("和"),r("code",[t._v("cv2.cornerSubPix()")]),r("br"),r("code",[t._v("cornerHarris")]),t._v("参数说明：")]),r("ul",[r("li",[t._v("img：输入图像，数据类型要是"),r("code",[t._v("float32")])]),r("li",[t._v("blockSize：角点检测中的邻域值")]),r("li",[t._v("ksize：使用"),r("code",[t._v("Sobel")]),t._v("函数求偏导的窗口大小")]),r("li",[t._v("k：角点检测参数，取值为0.04到0.06")])]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import cv2\nimport numpy as np\n\nfilename = 'test.jpg'\n\nim = cv2.imread(filename)\ngray = cv2.cvtColor(im, cv2.COLOR_RGB2GRAY)\ngray = np.float32(gray)\ndst = cv2.cornerHarris(gray, 2,3,0.04)\ndst = cv2.dilate(dst,None) #膨胀处理\nim[dst > 0.01*dst.max()] = [0,0,255]\ncv2.imshow('dst',im)\nif cv2.waitKey(0):\n    cv2.destroyAllWindows()\n")])]),r("p",[t._v("亚像素级精确度的角点："),r("br"),t._v("\n基本方法是"),r("code",[t._v("cornerSubPix")]),t._v("，首先需要先找到Harris角点，然后找到某个角点的所有角点坐标值的重心，传入"),r("code",[t._v("cornerSubPix")]),t._v("（因为一个角点上可能有一堆角点，所以要取重心）。我们用红色表示Harris角点，绿色表示修正后的角点。通过迭代运算到一定次数停止："),r("br")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("#coding=utf-8\n\nimport cv2\nimport numpy as np\n\nfilename = 'zui.jpg'\nimg = cv2.imread(filename)\ngray = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)\n\n# 找角点\ngray = np.float32(gray)\ndst = cv2.cornerHarris(gray,2,3,0.04)\ndst = cv2.dilate(dst,None)\nret,dst = cv2.threshold(dst,0.01*dst.max(),255,0)\ndst = np.uint8(dst)\n\n# 找重心\nret,labels,stats,centroids = cv2.connectedComponentsWithStats(dst)\n\n# 定义迭代次数\ncriteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.001)\ncorners = cv2.cornerSubPix(gray,np.float32(centroids),(5,5),(-1,-1),criteria) # 返回角点\n\nres = np.hstack((centroids,corners))\nres = np.int0(res)\nimg[res[:,1],res[:,0]] = [0,0,255]\nimg[res[:,3],res[:,2]] = [0,255,0]\n\ncv2.imshow('img',img)\nif cv2.waitKey(0):\n\tcv2.destroyAllWindows()\n")])]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('#coding=utf-8\n# 代码来自：https://zhuanlan.zhihu.com/p/36801693\nimport cv2\nimport numpy as np\n\n# 读取名称为 p14.png的图片\nimg = cv2.imread("p14.png",1)\nimg_org = cv2.imread("p14.png",1)\n\n# 转换为黑白图像\ngray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)\n\n# 转换为32为浮点数\ngray = np.float32(gray)\n\n# Harris角点操作\nprocessed = cv2.cornerHarris(gray,3,3,0.05)\n\n# 把角点颜色变为绿色\nimg[processed>0.03*processed.max()] = [0,255,0]\n\n# 显示原图和处理后的图像\ncv2.imshow("org",img_org)\ncv2.imshow("processed",img)\n\ncv2.waitKey(0)\n')])]),r("p",[r("br"),r("br")]),r("hr"),r("p"),r("p",[t._v("参考：")]),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/xiajun07061225/article/details/6910129",target:"_blank",rel:"noopener noreferrer"}},[t._v("matlab直方图均衡化详解及编程实现")])]),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/sunmc1204953974/article/details/50606395",target:"_blank",rel:"noopener noreferrer"}},[t._v("python图像直方图与直方图均衡化")])]),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/JohinieLi/article/details/69389980",target:"_blank",rel:"noopener noreferrer"}},[t._v("python 读取、保存、二值化、灰度化图片+opencv处理图片的方法")])]),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/tengfei461807914/article/details/76242362",target:"_blank",rel:"noopener noreferrer"}},[t._v("python opencv入门 形态学转换（13）")])]),r("li",[r("a",{attrs:{href:"https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_table_of_contents_imgproc/py_table_of_contents_imgproc.html#py-table-of-content-imgproc",target:"_blank",rel:"noopener noreferrer"}},[t._v("Python opencv英文文档")])]),r("li",[r("a",{attrs:{href:"https://www.kancloud.cn/aollo/aolloopencv/269602",target:"_blank",rel:"noopener noreferrer"}},[t._v("Python opencv官方文档汉化，看云提供")])]),r("li",[r("a",{attrs:{href:"http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_morphological_ops/py_morphological_ops.html?highlight=getstructuringelement",target:"_blank",rel:"noopener noreferrer"}},[t._v("OpenCV-Python Tuorials Morphological Transformations")])]),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/u010128736/article/details/52801310",target:"_blank",rel:"noopener noreferrer"}},[t._v("阈值化分割（二）OTSU法-附Python实现")])]),r("li",[r("a",{attrs:{href:"https://pythonprogramming.net/morphological-transformation-python-opencv-tutorial/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Morphological Transformations OpenCV Python Tutorial")])]),r("li",[r("a",{attrs:{href:"http://www.cnblogs.com/21207-iHome/articles/6254405.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("python opencv角点检测")])]),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/tengfei461807914/article/details/78009887",target:"_blank",rel:"noopener noreferrer"}},[t._v("python opencv入门 Harris角点检测（31）")])]),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/tengfei461807914/article/details/79492012",target:"_blank",rel:"noopener noreferrer"}},[t._v("python opencv入门 FAST角点检测算法（35）")])]),r("li",[r("a",{attrs:{href:"https://github.com/wizardforcel/py-ds-intro-tut-zh/blob/master/opencv.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("python opencv图像和视频分析")])]),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/sunny2038/article/details/9253823",target:"_blank",rel:"noopener noreferrer"}},[t._v("OpenCV-Python教程（9、使用霍夫变换检测直线）")])]),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/dcrmg/article/details/78880046",target:"_blank",rel:"noopener noreferrer"}},[t._v("OpenCV-Python 霍夫直线检测-HoughLinesP函数参数")])]),r("li",[r("a",{attrs:{href:"https://wax8280.github.io/2016/10/02/682/",target:"_blank",rel:"noopener noreferrer"}},[t._v("学习OpenCV-Python——检测")])]),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/on2way/article/details/46801063",target:"_blank",rel:"noopener noreferrer"}},[t._v("Python下opencv使用笔记（三）（图像的几何变换）")])]),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/on2way/article/details/46812121",target:"_blank",rel:"noopener noreferrer"}},[t._v("Python下opencv使用笔记（四）（图像的阈值处理）")])])])])}],!1,null,null,null);e.default=a.exports}}]);